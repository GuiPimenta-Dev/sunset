<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sunset - Screen Share</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js"></script>
  <style>
    :root {
      --text-primary: #ffffff;
      --text-secondary: rgba(255, 255, 255, 0.7);
      --bg-primary: #1a1a1a;
      --bg-secondary: #2a2a2a;
      --accent-color: #ff7e5f;
    }

    body {
      margin: 0;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    h1 {
      text-align: center;
      color: var(--text-primary);
      margin-bottom: 30px;
    }

    .video-container {
      position: relative;
      width: 100%;
      background: var(--bg-secondary);
      border-radius: 12px;
      overflow: hidden;
      margin-bottom: 20px;
    }

    #shared-screen {
      width: 100%;
      max-height: 80vh;
      background: #000;
    }

    .controls-overlay {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      padding: 8px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
    }

    .control-button {
      background: transparent;
      border: none;
      color: var(--text-primary);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .control-button:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .control-button.active {
      background: var(--accent-color);
    }

    .control-button .icon {
      font-size: 18px;
    }

    .tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      font-size: 12px;
      border-radius: 4px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      margin-bottom: 8px;
    }

    .control-button:hover .tooltip {
      opacity: 1;
      visibility: visible;
    }

    .danger {
      color: #ff4444;
    }

    .danger:hover {
      background: rgba(255, 68, 68, 0.1);
    }

    /* Timer e participantes */
    #call-timer {
      display: flex;
      align-items: center;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 6px 16px;
      border-radius: 6px;
      font-size: 15px;
      font-family: monospace;
      letter-spacing: 1px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.10);
    }

    #participants-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-left: 16px;
    }

    #participants-avatars {
      display: flex;
      gap: 6px;
    }

    .participant-avatar {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--accent-color);
      border: 2px solid #fff;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.12);
    }

    #participants-count {
      color: #fff;
      font-size: 12px;
      margin-top: 2px;
      font-family: monospace;
    }

    /* Gravação */
    #record-reminder {
      position: fixed;
      top: 18px;
      right: 18px;
      background: rgba(255, 126, 95, 0.92);
      color: white;
      padding: 6px 16px;
      border-radius: 6px;
      z-index: 2001;
      font-size: 13px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.10);
      max-width: 260px;
      align-items: center;
      display: none;
    }

    #dismiss-reminder {
      background: none;
      border: none;
      color: white;
      font-size: 15px;
      cursor: pointer;
      padding: 0 4px;
      line-height: 1;
      margin-left: 8px;
    }

    /* Room UI */
    .room-ui {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 40px;
    }

    .room-input {
      padding: 12px 20px;
      font-size: 16px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      width: 300px;
      max-width: 100%;
    }

    .room-button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 8px;
      background: var(--accent-color);
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .room-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 126, 95, 0.3);
    }

    .room-button:active {
      transform: translateY(0);
    }

    .notes-panel {
      position: fixed;
      right: -400px;
      top: 0;
      width: 400px;
      height: 100vh;
      background: var(--discord-dark);
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.3);
      transition: right 0.3s ease;
      z-index: 1000;
      display: flex;
      flex-direction: column;
    }

    .notes-panel.active {
      right: 0;
    }

    .notes-header {
      padding: 15px;
      background: var(--discord-darker);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .notes-title {
      color: var(--text-primary);
      font-size: 1.1rem;
      font-weight: 500;
    }

    .notes-close {
      background: none;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 5px;
      font-size: 1.2rem;
    }

    .notes-close:hover {
      color: var(--text-primary);
    }

    .notes-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .editor-toolbar {
      background: var(--discord-darker);
      border: none;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding: 4px;
      display: flex;
      align-items: center;
      gap: 0;
      flex-wrap: nowrap;
      min-height: 40px;
    }

    .toolbar-button {
      color: var(--text-secondary);
      border: none;
      background: transparent;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s ease;
      position: relative;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 10px;
      height: 24px;
      cursor: pointer;
      margin: 0 1px;
    }

    .toolbar-button:hover {
      background: transparent;
      color: var(--text-primary);
      box-shadow: 0 0 6px rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      border: none;
      padding: 4px;
    }

    .toolbar-button.active {
      background: var(--sunset-orange);
      color: white;
    }

    .toolbar-button::after {
      content: attr(title);
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      z-index: 1000;
    }

    .toolbar-button:hover::after {
      opacity: 1;
      visibility: visible;
    }

    .editor-area {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .markdown-editor {
      flex: 1;
      background: var(--discord-dark);
      color: var(--text-primary);
      border: none;
      font-size: 14px;
      line-height: 1.6;
      padding: 16px;
      resize: none;
      outline: none;
      font-family: 'Consolas', monospace;
    }

    .markdown-preview {
      flex: 1;
      background: var(--discord-dark);
      color: var(--text-primary);
      padding: 16px;
      font-size: 14px;
      line-height: 1.6;
      overflow-y: auto;
      display: none;
    }

    .markdown-preview.active {
      display: block;
    }

    .markdown-preview h1 {
      color: var(--sunset-orange);
      font-size: 2em;
      margin-bottom: 0.5em;
    }

    .markdown-preview h2 {
      color: var(--sunset-purple);
      font-size: 1.5em;
      margin-bottom: 0.5em;
    }

    .markdown-preview strong {
      color: var(--sunset-orange);
    }

    .markdown-preview em {
      color: var(--sunset-purple);
    }

    .notes-panel.fullscreen {
      width: 100%;
      right: 0;
    }

    .notes-header .toolbar-button {
      margin-left: 4px;
    }

    /* New styles for participant avatars */
    .participant-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--accent-color);
      border: 2px solid rgba(255, 255, 255, 0.9);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 -4px;
      transition: all 0.3s ease;
      position: relative;
      z-index: 1;
    }

    .participant-avatar:hover {
      transform: scale(1.1) translateY(-2px);
      z-index: 2;
    }

    #participants-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-left: 16px;
    }

    #participants-avatars {
      display: flex;
      gap: 2px;
      padding: 4px;
      transition: all 0.3s ease;
    }

    #participants-count {
      color: #fff;
      font-size: 12px;
      margin-top: 4px;
      font-family: monospace;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }

    .notes-preview.active {
      display: block;
    }

    .notes-preview h1 {
      color: var(--sunset-orange);
      font-size: 2em;
      margin-bottom: 0.5em;
    }

    .notes-preview h2 {
      color: var(--sunset-purple);
      font-size: 1.5em;
      margin-bottom: 0.5em;
    }

    .notes-preview strong {
      color: var(--sunset-orange);
    }

    .notes-preview em {
      color: var(--sunset-purple);
    }

    .notes-panel.fullscreen {
      width: 100%;
      right: 0;
    }

    .notes-header .toolbar-button {
      margin-left: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Sunset</h1>

    <!-- Room UI -->
    <div id="room-ui" class="room-ui">
      <input type="text" id="room-input" class="room-input" placeholder="Digite o nome da sala">
      <button id="join-room" class="room-button">Entrar na Sala</button>
    </div>

    <!-- Video Container (inicialmente oculto) -->
    <div id="video-container" class="video-container" style="display: none;">
      <video id="shared-screen" autoplay playsinline></video>
      <div class="controls-overlay">
        <button id="toggle-mic" class="control-button" title="Mute/Unmute Microphone">
          <i class="fas fa-microphone icon"></i>
          <span class="tooltip">Mute Microphone</span>
        </button>
        <button id="share-screen" class="control-button" title="Share Screen">
          <i class="fas fa-desktop icon"></i>
          <span class="tooltip">Share Screen</span>
        </button>
        <button id="stop-sharing" class="control-button danger" title="Stop Sharing" style="display: none;">
          <i class="fas fa-stop icon"></i>
          <span class="tooltip">Stop Sharing</span>
        </button>
        <button id="record" class="control-button" title="Start Recording">
          <i class="fas fa-circle icon"></i>
          <span class="tooltip">Start Recording</span>
        </button>
        <button id="notes" class="control-button" title="Open Notes">
          <i class="fas fa-sticky-note icon"></i>
          <span class="tooltip">Open Notes</span>
        </button>
        <button id="leave-room" class="control-button danger" style="background:#ff4444;color:white;" title="Leave Room">
          <i class="fas fa-phone-slash icon"></i>
          <span class="tooltip">Leave Room</span>
        </button>
      </div>
    </div>

    <!-- Notes Component -->
    <div class="notes-panel">
      <div class="notes-drag-handle"></div>
      <div class="notes-header">
        <span class="notes-title">Notes</span>
        <div>
          <button class="toolbar-button" title="Visualizar" onclick="togglePreview()">
            <i class="fa fa-eye"></i>
          </button>
          <button class="toolbar-button" title="Tela Cheia" onclick="toggleFullscreen()">
            <i class="fa fa-expand"></i>
          </button>
          <button class="notes-close" title="Close Notes">
            <i class="fas fa-times"></i>
          </button>
        </div>
      </div>
      <div class="notes-content">
        <div class="editor-toolbar">
          <button class="toolbar-button" title="Título Principal" onclick="formatText('# ')">
            <i class="fa fa-header"></i>
          </button>
          <button class="toolbar-button" title="Subtítulo" onclick="formatText('## ')">
            <i class="fa fa-header fa-sm"></i>
          </button>
          <button class="toolbar-button" title="Negrito" onclick="formatText('**', '**')">
            <i class="fa fa-bold"></i>
          </button>
          <button class="toolbar-button" title="Itálico" onclick="formatText('*', '*')">
            <i class="fa fa-italic"></i>
          </button>
          <button class="toolbar-button" title="Lista não ordenada" onclick="formatText('- ')">
            <i class="fa fa-list-ul"></i>
          </button>
          <button class="toolbar-button" title="Lista ordenada" onclick="formatText('1. ')">
            <i class="fa fa-list-ol"></i>
          </button>
          <button class="toolbar-button" title="Lista de tarefas" onclick="formatText('- [ ] ')">
            <i class="fa fa-tasks"></i>
          </button>
          <button class="toolbar-button" title="Link" onclick="formatText('[', '](url)')">
            <i class="fa fa-link"></i>
          </button>
          <button class="toolbar-button" title="Imagem" onclick="formatText('![', '](url)')">
            <i class="fa fa-image"></i>
          </button>
          <button class="toolbar-button" title="Citação" onclick="formatText('> ')">
            <i class="fa fa-quote-left"></i>
          </button>
          <button class="toolbar-button" title="Código" onclick="formatText('`', '`')">
            <i class="fa fa-code"></i>
          </button>
          <button class="toolbar-button" title="Bloco de código" onclick="formatText('```\n', '\n```')">
            <i class="fa fa-file-code"></i>
          </button>
          <button class="toolbar-button" title="Linha horizontal" onclick="formatText('\n---\n')">
            <i class="fa fa-minus"></i>
          </button>
        </div>
        <div class="editor-area">
          <textarea id="markdown-editor" class="markdown-editor" placeholder="Anote aqui os tópicos importantes da reunião..."></textarea>
          <div id="markdown-preview" class="markdown-preview"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Timer -->
  <div style="display:flex;align-items:flex-start;position:fixed;top:18px;left:18px;z-index:2000;">
    <div id="call-timer">
      <button id="timer-toggle" style="background:none;border:none;color:white;font-size:16px;cursor:pointer;margin-right:8px;outline:none;">
        <i id="timer-toggle-icon" class="fa fa-play"></i>
      </button>
      <span id="timer-text">00:00:00</span>
    </div>
  </div>

  <!-- Lembrete de gravação -->
  <div id="record-reminder" style="position:fixed;top:18px;right:18px;background:rgba(255,126,95,0.92);color:white;padding:6px 16px;border-radius:6px;z-index:2001;font-size:13px;box-shadow:0 2px 8px rgba(0,0,0,0.10);max-width:260px;align-items:center;display:none;">
    <span>Não esqueça de gravar a ligação para poder revê-la no futuro</span>
    <button id="dismiss-reminder" style="background:none;border:none;color:white;font-size:15px;cursor:pointer;padding:0 4px;line-height:1;margin-left:8px;">&times;</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    // Elementos DOM
    const roomUI = document.getElementById('room-ui');
    const videoContainer = document.getElementById('video-container');
    const roomInput = document.getElementById('room-input');
    const joinRoomButton = document.getElementById('join-room');
    const sharedScreen = document.getElementById('shared-screen');
    const toggleMicButton = document.getElementById('toggle-mic');
    const shareScreenButton = document.getElementById('share-screen');
    const stopSharingButton = document.getElementById('stop-sharing');
    const recordButton = document.getElementById('record');
    const leaveRoomButton = document.getElementById('leave-room');
    const timerToggle = document.getElementById('timer-toggle');
    const timerText = document.getElementById('timer-text');
    const participantsAvatars = document.getElementById('participants-avatars');
    const participantsCount = document.getElementById('participants-count');

    // Variáveis de estado
    let room = null;
    let localParticipant = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let timerInterval = null;
    let timerStart = null;
    let timerPausedAt = null;
    let timerRunning = false;

    // Notes functionality
    const notesButton = document.getElementById("notes");
    const notesPanel = document.querySelector(".notes-panel");
    const notesClose = document.querySelector(".notes-close");
    const markdownEditor = document.getElementById("markdown-editor");
    const markdownPreview = document.getElementById("markdown-preview");
    let isPreviewMode = false;
    let isFullscreen = false;

    // Função para atualizar participantes
    function updateParticipants() {
      try {
        if (!room) {
          console.log('Room not initialized');
          participantsCount.textContent = '0 participantes';
          participantsAvatars.innerHTML = '';
          return;
        }

        // Corrigido: obter participantes remotos corretamente
        let remoteParticipants = [];
        if (room.participants) {
          // Em algumas versões do LiveKit, participants é um Map
          if (typeof room.participants.values === 'function') {
            remoteParticipants = Array.from(room.participants.values());
          } 
          // Em outras versões pode ser um objeto normal
          else if (room.participants instanceof Object) {
            remoteParticipants = Object.values(room.participants);
          }
        }
        
        console.log('Remote participants count:', remoteParticipants.length);
        
        // Debug logs
        const roomState = {
          roomName: room.name,
          localParticipant: room.localParticipant?.identity,
          remoteParticipants: remoteParticipants.map(p => p.identity),
          totalParticipants: remoteParticipants.length + 1
        };
        console.log('Updating participants. Room state:', roomState);

        // Collect all participants
        const allParticipants = [];
        
        // Add local participant
        if (room.localParticipant) {
          console.log('Adding local participant:', room.localParticipant.identity);
          allParticipants.push(room.localParticipant);
        }

        // Add all remote participants
        remoteParticipants.forEach(participant => {
          if (participant && participant.identity) {
            console.log('Adding remote participant:', participant.identity);
            allParticipants.push(participant);
          }
        });

        // Update participant count
        const totalParticipants = allParticipants.length;
        console.log(`Total participants: ${totalParticipants} (Local: ${room.localParticipant ? 1 : 0}, Remote: ${remoteParticipants.length})`);
        participantsCount.textContent = `${totalParticipants} participante${totalParticipants !== 1 ? 's' : ''}`;

        // Clear and update avatars
        participantsAvatars.innerHTML = '';
        
        allParticipants.forEach((participant, index) => {
          if (!participant || !participant.identity) return;

          const avatar = document.createElement('div');
          avatar.className = 'participant-avatar';
          
          const initial = participant.identity.replace('user-', '').charAt(0).toUpperCase();
          avatar.title = participant.identity;
          avatar.innerHTML = `<span style="font-size: 12px; color: white;">${initial}</span>`;
          
          const hue = Math.abs(participant.identity.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)) % 360;
          avatar.style.backgroundColor = `hsl(${hue}, 70%, 60%)`;
          
          if (totalParticipants > 3) {
            const angle = (2 * Math.PI * index) / totalParticipants;
            const radius = 15;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            avatar.style.transform = `translate(${x}px, ${y}px)`;
          }
          
          participantsAvatars.appendChild(avatar);
        });

        // Update container style
        participantsAvatars.style.display = 'flex';
        participantsAvatars.style.justifyContent = 'center';
        participantsAvatars.style.alignItems = 'center';
        
        if (totalParticipants > 3) {
          participantsAvatars.style.width = '50px';
          participantsAvatars.style.height = '50px';
          participantsAvatars.style.position = 'relative';
        } else {
          participantsAvatars.style.width = 'auto';
          participantsAvatars.style.height = 'auto';
          participantsAvatars.style.position = 'static';
        }

      } catch (error) {
        console.error('Error updating participants:', error);
      }
    }

    async function getToken(roomName) {
      const response = await fetch('http://localhost:3000/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          room: roomName,
          identity: `user-${Math.random().toString(36).substring(2, 10)}`
        })
      });

      if (!response.ok) throw new Error('Failed to get token');
      const { token } = await response.json();
      return token;
    }

    async function connectToRoom(roomName) {
      try {
        console.log('Starting connection to room:', roomName);
        
        // Get token
        console.log('Requesting token from backend...');
        const token = await getToken(roomName);
        console.log('Token received successfully');
        
        // Initialize room
        console.log('Initializing LiveKit room...');
        room = new LivekitClient.Room({
          adaptiveStream: true,
          dynacast: true,
          publishDefaults: {
            simulcast: true,
            videoEncoding: {
              maxBitrate: 6000000,
              maxFramerate: 60
            }
          },
        });

        // Setup event listeners before connecting
        console.log('Setting up room event listeners...');
        
        room.on(LivekitClient.RoomEvent.Connected, () => {
          console.log('Successfully connected to room:', room.name);
          roomUI.style.display = 'none';
          videoContainer.style.display = 'block';
          startCallTimer();
        });

        room.on(LivekitClient.RoomEvent.Disconnected, (reason) => {
          console.log('Disconnected from room:', room.name, 'Reason:', reason);
          roomUI.style.display = 'flex';
          videoContainer.style.display = 'none';
        });

        room.on(LivekitClient.RoomEvent.Reconnecting, () => {
          console.log('Attempting to reconnect to room:', room.name);
        });

        room.on(LivekitClient.RoomEvent.Reconnected, () => {
          console.log('Successfully reconnected to room:', room.name);
        });

        room.on(LivekitClient.RoomEvent.ConnectionStateChanged, (state) => {
          console.log('Connection state changed:', state);
        });

        // Setup screen share handling
        room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, publication, participant) => {
          console.log('Track subscribed:', {
            trackSource: track.source,
            participant: participant.identity,
            publication: publication.kind,
            trackId: track.sid,
            trackName: track.name,
            trackKind: track.kind,
            trackEnabled: track.enabled,
            trackMuted: track.muted
          });
          
          // Check for screen share track by name or source
          if (track.name === 'screen-share' || track.source === LivekitClient.Track.Source.ScreenShare) {
            console.log('Screen share track received from:', participant.identity);
            
            // Create a new MediaStream with the track
            const stream = new MediaStream([track.mediaStreamTrack]);
            
            // Configure video element
            sharedScreen.style.width = '100%';
            sharedScreen.style.height = 'auto';
            sharedScreen.style.objectFit = 'contain';
            sharedScreen.style.backgroundColor = '#000';
            
            // Set the stream to the video element
            sharedScreen.srcObject = stream;
            shareScreenButton.style.display = 'none';
            stopSharingButton.style.display = 'flex';

            // Log video element state
            console.log('Video element state:', {
              readyState: sharedScreen.readyState,
              error: sharedScreen.error,
              srcObject: sharedScreen.srcObject ? 'set' : 'not set',
              videoWidth: sharedScreen.videoWidth,
              videoHeight: sharedScreen.videoHeight
            });

            // Handle track ended event
            track.mediaStreamTrack.onended = () => {
              console.log('Remote screen share ended');
              if (sharedScreen.srcObject) {
                sharedScreen.srcObject.getTracks().forEach(t => t.stop());
                sharedScreen.srcObject = null;
              }
              shareScreenButton.style.display = 'flex';
              stopSharingButton.style.display = 'none';
            };

            // Log when the video starts playing
            sharedScreen.onplaying = () => {
              console.log('Screen share video started playing');
              console.log('Video dimensions:', {
                width: sharedScreen.videoWidth,
                height: sharedScreen.videoHeight
              });
            };

            // Log any video errors
            sharedScreen.onerror = (error) => {
              console.error('Screen share video error:', error);
            };

            // Log track state changes
            track.on(LivekitClient.TrackEvent.Enabled, () => {
              console.log('Screen share track enabled');
            });

            track.on(LivekitClient.TrackEvent.Disabled, () => {
              console.log('Screen share track disabled');
            });

            track.on(LivekitClient.TrackEvent.Ended, () => {
              console.log('Screen share track ended');
            });

            // Force play the video
            sharedScreen.play().catch(error => {
              console.error('Error playing video:', error);
            });
          }
        });

        room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track, publication, participant) => {
          console.log('Track unsubscribed:', {
            trackSource: track.source,
            participant: participant.identity,
            publication: publication.kind,
            trackId: track.sid,
            trackName: track.name
          });
          
          if (track.source === LivekitClient.Track.Source.ScreenShare) {
            console.log('Screen share track ended from:', participant.identity);
            if (sharedScreen.srcObject) {
              sharedScreen.srcObject.getTracks().forEach(track => track.stop());
              sharedScreen.srcObject = null;
            }
            shareScreenButton.style.display = 'flex';
            stopSharingButton.style.display = 'none';
          }
        });

        // Connect to room
        console.log('Connecting to LiveKit server...');
        await room.connect('ws://localhost:7880', token, {
          autoSubscribe: true,
          rtcConfig: {
            iceServers: [
              {
                urls: ['stun:stun.l.google.com:19302']
              }
            ]
          }
        });
        console.log('Room connection initiated');

      } catch (error) {
        console.error('Failed to connect to room:', error);
        console.error('Error details:', {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
        alert('Failed to connect to room: ' + error.message);
        
        // Cleanup on error
        if (room) {
          try {
            await room.disconnect();
          } catch (disconnectError) {
            console.error('Error during cleanup:', disconnectError);
          }
        }
      }
    }

    // Função para compartilhar tela
    async function shareScreen() {
      try {
        if (!room || !room.localParticipant) {
          console.error('Not connected to room');
          return;
        }

        console.log('Starting screen share...');
        const screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: { ideal: 30 }
          }
        });

        console.log('Screen share stream obtained:', screenStream.getVideoTracks()[0].label);
        
        // Create a new track from the screen share stream
        const videoTrack = screenStream.getVideoTracks()[0];
        const screenTrack = new LivekitClient.LocalVideoTrack(videoTrack, {
          name: 'screen-share',
          source: LivekitClient.Track.Source.ScreenShare,
          resolution: {
            width: 1920,
            height: 1080,
            frameRate: 30
          }
        });

        // Set track metadata
        screenTrack.source = LivekitClient.Track.Source.ScreenShare;
        screenTrack.name = 'screen-share';
        
        // Publish the track
        console.log('Publishing screen share track...');
        await room.localParticipant.publishTrack(screenTrack);
        console.log('Screen share track published successfully');

        // Configure video element
        sharedScreen.style.width = '100%';
        sharedScreen.style.height = 'auto';
        sharedScreen.style.objectFit = 'contain';
        sharedScreen.style.backgroundColor = '#000';

        // Set the local preview
        sharedScreen.srcObject = screenStream;
        shareScreenButton.style.display = 'none';
        stopSharingButton.style.display = 'flex';

        // Force play the video
        sharedScreen.play().catch(error => {
          console.error('Error playing video:', error);
        });

        // Handle when user stops sharing through browser UI
        videoTrack.onended = () => {
          console.log('Screen share ended by user');
          stopSharing();
        };

      } catch (error) {
        console.error('Failed to share screen:', error);
        alert('Failed to share screen: ' + error.message);
      }
    }

    // Função para parar compartilhamento
    async function stopSharing() {
      try {
        if (!room || !room.localParticipant) return;

        const tracks = room.localParticipant.getTracks();
        const screenTrack = tracks.find(track => track.source === LivekitClient.Track.Source.ScreenShare);
        
        if (screenTrack) {
          await room.localParticipant.unpublishTrack(screenTrack);
          screenTrack.stop();
        }

        if (sharedScreen.srcObject) {
          sharedScreen.srcObject.getTracks().forEach(track => track.stop());
          sharedScreen.srcObject = null;
        }

        shareScreenButton.style.display = 'flex';
        stopSharingButton.style.display = 'none';
      } catch (error) {
        console.error('Error stopping screen share:', error);
      }
    }

    // Função para alternar microfone
    async function toggleMicrophone() {
      if (!localParticipant) return;

      const audioTrack = localParticipant.tracks.find(
        pub => pub.track.kind === 'audio'
      );

      if (audioTrack) {
        const isMuted = !audioTrack.track.isMuted;
        await audioTrack.track.setMuted(isMuted);
        toggleMicButton.classList.toggle('active', isMuted);
        toggleMicButton.querySelector('.icon').className = isMuted ? 'fas fa-microphone-slash icon' : 'fas fa-microphone icon';
        toggleMicButton.querySelector('.tooltip').textContent = isMuted ? 'Unmute Microphone' : 'Mute Microphone';
      }
    }

    // Função para gravar
    function toggleRecording() {
      if (!isRecording) {
        if (!sharedScreen.srcObject) {
          alert('Nenhum stream disponível para gravar. Inicie uma chamada ou compartilhe a tela primeiro.');
          return;
        }

        recordedChunks = [];
        mediaRecorder = new MediaRecorder(sharedScreen.srcObject, {
          mimeType: 'video/webm;codecs=vp9,opus',
          audioBitsPerSecond: 192000
        });

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          document.body.appendChild(a);
          a.style.display = 'none';
          a.href = url;
          a.download = `recording-${new Date().toISOString()}.webm`;
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
        };

        mediaRecorder.start();
        isRecording = true;
        recordButton.classList.add('recording');
        recordButton.querySelector('.icon').className = 'fas fa-stop icon';
        recordButton.querySelector('.tooltip').textContent = 'Stop Recording';
        hideRecordReminder();
      } else {
        mediaRecorder.stop();
        isRecording = false;
        recordButton.classList.remove('recording');
        recordButton.querySelector('.icon').className = 'fas fa-circle icon';
        recordButton.querySelector('.tooltip').textContent = 'Start Recording';
      }
    }

    // Funções do timer
    function updateTimerDisplay() {
      if (!timerText) return;
      let elapsed = 0;
      if (timerRunning && timerStart) {
        elapsed = Date.now() - timerStart;
      } else if (timerPausedAt && timerStart) {
        elapsed = timerPausedAt - timerStart;
      }
      const hours = String(Math.floor(elapsed / 3600000)).padStart(2, '0');
      const minutes = String(Math.floor((elapsed % 3600000) / 60000)).padStart(2, '0');
      const seconds = String(Math.floor((elapsed % 60000) / 1000)).padStart(2, '0');
      timerText.textContent = `${hours}:${minutes}:${seconds}`;
    }

    function startCallTimer() {
      if (!timerRunning) {
        timerStart = Date.now() - (timerPausedAt ? timerPausedAt - timerStart : 0);
        timerPausedAt = null;
        timerRunning = true;
        timerToggle.querySelector('i').className = 'fa fa-pause';
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(updateTimerDisplay, 1000);
        updateTimerDisplay();
      }
    }

    function pauseCallTimer() {
      if (timerRunning) {
        timerPausedAt = Date.now();
        timerRunning = false;
        timerToggle.querySelector('i').className = 'fa fa-play';
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }
    }

    function toggleTimer() {
      if (timerRunning) {
        pauseCallTimer();
      } else {
        startCallTimer();
      }
    }

    // Funções do lembrete de gravação
    function showRecordReminder() {
      const reminder = document.getElementById('record-reminder');
      reminder.style.display = 'flex';
    }

    function hideRecordReminder() {
      const reminder = document.getElementById('record-reminder');
      reminder.style.display = 'none';
    }

    document.getElementById('dismiss-reminder').onclick = hideRecordReminder;

    // Mostrar lembrete após 5 minutos se não estiver gravando
    setTimeout(() => {
      if (!isRecording && room) {
        showRecordReminder();
      }
    }, 5 * 60 * 1000);

    // Load saved notes
    markdownEditor.value = localStorage.getItem('notes-' + roomInput.value) || '';

    notesButton.addEventListener("click", () => {
      notesPanel.classList.toggle("active");
    });

    notesClose.addEventListener("click", () => {
      notesPanel.classList.remove("active");
    });

    function togglePreview() {
      isPreviewMode = !isPreviewMode;
      markdownEditor.style.display = isPreviewMode ? 'none' : 'block';
      markdownPreview.style.display = isPreviewMode ? 'block' : 'none';
      if (isPreviewMode) {
        markdownPreview.innerHTML = marked.parse(markdownEditor.value);
      }
    }

    function toggleFullscreen() {
      isFullscreen = !isFullscreen;
      notesPanel.classList.toggle('fullscreen', isFullscreen);
    }

    function formatText(prefix, suffix = '') {
      const start = markdownEditor.selectionStart;
      const end = markdownEditor.selectionEnd;
      const text = markdownEditor.value;
      const before = text.substring(0, start);
      const selection = text.substring(start, end);
      const after = text.substring(end);
      
      markdownEditor.value = before + prefix + selection + suffix + after;
      markdownEditor.focus();
      
      if (selection.length > 0) {
        markdownEditor.selectionStart = start + prefix.length;
        markdownEditor.selectionEnd = end + prefix.length;
      } else {
        markdownEditor.selectionStart = markdownEditor.selectionEnd = start + prefix.length;
      }
    }

    // Auto-save notes
    markdownEditor.addEventListener('input', () => {
      localStorage.setItem('notes-' + roomInput.value, markdownEditor.value);
    });

    // Event Listeners
    joinRoomButton.addEventListener('click', () => {
      const roomName = roomInput.value.trim();
      if (roomName) {
        connectToRoom(roomName);
      }
    });

    toggleMicButton.addEventListener('click', toggleMicrophone);
    shareScreenButton.addEventListener('click', shareScreen);
    stopSharingButton.addEventListener('click', stopSharing);
    recordButton.addEventListener('click', toggleRecording);
    timerToggle.addEventListener('click', toggleTimer);

    leaveRoomButton.addEventListener('click', async () => {
      if (isRecording) {
        toggleRecording(); // Para a gravação se estiver ativa
      }
      if (room) {
        await room.disconnect();
      }
      roomUI.style.display = 'flex';
      videoContainer.style.display = 'none';
      sharedScreen.srcObject = null;
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      timerText.textContent = '00:00:00';
      timerStart = null;
      timerPausedAt = null;
      timerRunning = false;
      timerToggle.querySelector('i').className = 'fa fa-play';
    });

    function setupScreenShare() {
      const screenShareButton = document.getElementById('screen-share-button');
      const stopScreenShareButton = document.getElementById('stop-screen-share-button');

      screenShareButton.onclick = async () => {
        screenShareButton.disabled = true;
        stopScreenShareButton.disabled = false;

        try {
          screenTrack = await LivekitClient.createScreenShareTrack({
            resolution: {
              width: 1920,
              height: 1080,
              frameRate: 30,
            },
          });
          
          await room.localParticipant.publishTrack(screenTrack);
          console.log('Screen share started');
        } catch (e) {
          console.error('Failed to share screen:', e);
          screenShareButton.disabled = false;
          stopScreenShareButton.disabled = true;
        }
      };

      stopScreenShareButton.onclick = async () => {
        if (screenTrack) {
          await room.localParticipant.unpublishTrack(screenTrack);
          screenTrack.stop();
          screenTrack = null;
          console.log('Screen share stopped');
        }
        screenShareButton.disabled = false;
        stopScreenShareButton.disabled = true;
      };
    }

    function setupDeviceSelection() {
      const videoInput = document.getElementById('video-input');
      const audioInput = document.getElementById('audio-input');

      LivekitClient.getLocalDevices('videoinput')
        .then(devices => {
          videoInput.innerHTML = '';
          devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label;
            videoInput.appendChild(option);
          });
        })
        .catch(console.error);

      LivekitClient.getLocalDevices('audioinput')
        .then(devices => {
          audioInput.innerHTML = '';
          devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label;
            audioInput.appendChild(option);
          });
        })
        .catch(console.error);
    }
  </script>
</body>
</html>